<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=us-ascii">

  <title>Java(tm) API for XML Web Services 2.0 - Dispatch</title>
  <meta name="CREATED" content="20050329;17163443">
  <meta name="CHANGED" content="20050403;19140562">
<style type="text/css">

        <!--
@page { size: 8.5in 11in }
-->

</style>
</head>

<body lang="en-US" dir="ltr">
  <h1>JAX-WS 2.0 Early Access 2<br>
  Dispatch&lt;T&gt;</h1>
  <hr>

  <p>Last Modified: 07/20/05</p>

  <p>Web service client applications may choose to work at the XML message level by using the <code>Dispatch&lt;T&gt;</code> APIs. The <code>javax.xml.rpc.Dispatch&lt;T&gt;</code> interface provides support for the dynamic invocation of service endpoint operations.</p>

  <p>Four Message Exchange Protocols(MEP) are supported: request-response, one way, asynchronous polling, and callback. Each of these invocation MEPs are required with JAXB data bound <code>java.lang.Object</code>, <code>javax.xml.transform.Source</code>, and <code>javax.xml.soap.SOAPMessage</code> object requests.</p>

  <p>The <code>javax.xml.rpc.Service</code> interface acts as a factory for the creation of <code>Dispatch</code> instances. In addition, a <code>Dispatch</code> instance is created in either <code>Service.Mode.PAYLOAD</code> or <code>Service.Mode.MESSAGE</code> modes. A <code>javax.xml.soap.SOAPMessage</code> request can only be used with a Dispatch instance of <code>Service.Mode.MESSAGE</code>.</p>

  <p>Note that the <code>Dispatch&lt;T&gt;</code> instance simply acts as a conduit for the request. No validation of the message is required to be performed by the implementation, though some may catch errors during request processing. Additionally, <code>Dispatch&lt;T&gt;</code> has no knowledge of the web service and the WSDL definition. It is up to the client program to supply well-formed XML requests.</p>

  <h2>Programming model</h2>

  <h3>Create a <code>Service</code> instance.</h3>

  <p>The <code>javax.xml.rpc.ServiceFactory</code> acts as a factory for the creation of <code>Service</code> instances. When created for use with <code>Dispatch</code> APIs the <code>Service</code> created is a non-configured <code>Service</code>. That is, the <code>Service</code> has no knowledge of the web service WSDL file other than what the client developer supplies.</p>

  <p>The easiest way to create a <code>Service</code> is show here:</p>
  <pre>
Service serviceFactory = ServiceFactory.newInstance();
Service service = serviceFactory.createService(serviceQName);
</pre>

  <p>Other methods in <code>ServiceFactory</code> may be used to create a <code>Service</code>. However, they are not supported in this EA release of JAXRPC 2.0. In these cases, the created service would still be devoid of the WSDL knowledge of the web service types, messages, and operations.</p>

  <p>A <code>Dispatch&lt;T&gt;</code> instance must be bound to a specific port and endpoint before use. The service instance has a <code>createPort(QName portName, URI bindingID, String endpointAddress)</code> method that the client program can invoke for <code>Dispatch&lt;T&gt;</code> objects. Ports created using this method can only be used with <code>Dispatch</code> instances.</p>

  <p>Those developers who have used web service applications in the past are familiar with the port <code>QName</code> and endpoint parameters of this method. Currently, the JAXRPC 2.0 EA2 implementation supports two <code>Binding</code> URI's, that of the SOAP 1.1 and SOAP 1.2 Bindings. For more information on SOAP 1.2 support please refer to the SOAP 1.2 documents.</p>

  <p>The creation of the SOAP 1.1 port using the <code>Service</code> API is shown here:</p>
  <pre>
service.createPort(QName portName, URI new URI(SOAPBinding.SOAP11HTTP_BINDING),String endpointAddress);
</pre>

<p>SOAP 1.2 support has been implemented for <code>Dispatch</code>. This requires only one change in the programming model. The creation of the SOAP 1.2 port using the <code>Service</code> API is shown here:</p>
  <pre>
service.createPort(QName portName, URI new URI(SOAPBinding.SOAP12HTTP_BINDING),String endpointAddress);
</pre>

  <h3>Create a <code>Dispatch</code> instance.</h3>

  <p>The <code>Dispatch</code> object can be created using either of these two <code>Service</code> methods:</p>
  <pre>
Dispatch dispatch = service.createDispatch(QName portName, Class clazz, Service.Mode mode);
Dispatch dispatch = service.createDispatch(QName portName, JAXBContext jaxbcontext, Service.Mode mode);
</pre>

  <p>For a <code>javax.xml.transform.Source</code> and JAXB data binding <code>java.lang.Object</code> <code>Dispatch&lt;T&gt;</code> can be created in both <code>Service.Mode.PAYLOAD</code> and <code>Service.Mode.MESSAGE</code> modes. A <code>javax.xml.soap.SOAPMessage</code> can only be created in <code>Service.Mode.MESSAGE</code> mode. The first form of the <code>createDispatch</code> method is used to create a <code>javax.xml.transform.Source</code> or <code>javax.xml.soap.SOAPMessage</code> specific to the <code>Dispatch&lt;T&gt;</code> instance.</p>

  <p>A JAXB object-specific instance can only be created using the second method listed above.</p>

  <p>It is important to note that once the <code>Dispatch&lt;T&gt;</code> instance is created it is static. That is, its <code>Service.Mode</code> or request type can not be changed. The instance can be reused given the caveat that if it is a JAXB-specific <code>Dispatch&lt;T&gt;</code> it must be reused with objects known to the same <code>JAXBContext</code>.</p>

  <h3>Set the <code>JAXRPCContext</code> for the request.</h3>

  <p style="margin-top: 0.17in; page-break-after: avoid">The <code>Dispatch&lt;T&gt;</code> interface extends the <code>javax.xml.rpc.BindingProvider</code> interface. The <code>BindingProvider</code> interface defines accessor methods for the <code>JAXRPCContext</code> request and response context. Standard <code>BindingProvider</code> properties are defined by the JAXRPC 2.0 Early Draft specification and the client program may set and get these properties. The application may also define application-specific properties, but the specification discourages this for portability reasons.</p>

  <h3>Prepare the message request.</h3>

  <p>This is the client developer's responsibility. For examples of how to prepare specific request types refer to the <code>Dispatch</code> sample applications.</p>

  <h3>Invoke the web service request.</h3>

  <p>Four types of invocation MEPs are supported using the methods below. In methods that produce a response, the type of <code>Object</code> returned will be of the same type as the request. For example, a <code>SOAPMessage</code> request will return a <code>SOAPMessage</code> response.</p>
  <pre>
Object response = dispatch.invoke(T);
dispatch.invokeOneway(T);
Response&lt;T&gt; response = dispatch.invokeAsync(T);
Future&lt;?&gt; response = dispatch.invokeAsync(T, AsyncHandler);
</pre>

  <h2>Dispatch and Asynchronous Invocations</h2>

  <p>Asynchronous invocations require special consideration. The first form of the <code>invokeAsync</code> method is a polling method. The response, <code>Response&lt;T&gt;</code>,returns to the user immediately and may be polled for completion. In the meantime, the client program can do other work.</p>

  <p>The <code>javax.xml.ws.Response&lt;T&gt;</code> implements the <code>java.util.concurrent.Future&lt;T&gt;</code> interface that is included in J2SE 5.0. The <code>Response&lt;T&gt;</code> object returns the actual response via its <code>get</code> method, which blocks if the response is not ready to be returned.</p>

  <p>The <code>Future&lt;T&gt;</code> interface also has a <code>cancel</code> method that will attempt to cancel the request invocation if the request is being invoked.</p>

  <p>Faults returned from the service or exceptions thrown during the invocation are returned when the Resp<code>onse&lt;T&gt;</code> <code>get</code> method is called. Because the execution doesn't occur in the main thread, the exception or fault returned is wrapped in an <code>java.util.concurrent.ExecutionException</code>. To obtain the actual cause use the <code>getCause</code> method of <code>ExecutionException</code>.</p>

  <p>For more information on the <code>java.util.concurrent.Future&lt;?&gt;</code> interface see the J2SE 5.0 documentation.</p>
  <pre>
public interface Response&lt;T&gt;extends java.util.concurrent.Future&lt;T&gt;{
        JAXRPCContext getContext();
}
</pre>

  <p>The second form of the <code>invokeAsync</code> method has a second parameter of type <code>javax.xml.ws.AsyncHandler</code>. The purpose of the <code>AsyncHandler</code> is to get and handle the the response or any fault thrown in an application-specific way. The <code>AsyncHandler</code> has a method <code>handleResponse(Response&lt;T&gt;)</code> that takes a <code>javax.xml.ws.Response&lt;T&gt;</code> parameter. This method gets the response or any faults and processes them according to behavior defined in the application. Note that it is the responsibility of the client program to implement the asynchronous handler.</p>
  <pre>
class ResponseHandler implements javax.xml.ws.AsyncHandler{
        public handleResponse(Response&lt;T&gt;);
}
</pre>

  <p>This form of the asynchronous invocation method returns a <code>Future&lt;?&gt;</code> object with wildcard type. As in the asynchronous poll invocation, the <code>Future&lt;T&gt;</code> object can be polled to see if the response is ready. However, calling the <code>get</code> method will not return the response of the invocation, but an object of indeterminate type.</p>

  <p>Examples of synchronous and asynchronous invocations are shown in the <code>Dispatch</code> samples. For convenience an example of <code>Response</code> usage is display here:</p>
  <pre>
Response&lt;Source&gt; response = dispatch.invokeAsync(Source);
while (!response.isDone()){
//go off and do some work
}

try {
        //get the actual result
        Source result = (javax.xml.transform.Source)response.get();
        //do something with the result
} catch (ExecutionException ex){
        //get the actual cause
        Throwable cause = ex.getCause();
} catch (InterupptedException ie){
        //note interruptions
        System.out.println("Operation invocation interrupted");
}
</pre>
  <hr>

  <p><a href="Copyright.html"><i><font size="2">Copyright &copy; 2005 Sun Microsystems, Inc. All rights reserved.</font></i></a></p>

  <p><br>
  <br></p>
</body>
</html>
